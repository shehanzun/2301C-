闭包
闭包原理依靠作用域
闭包优点可以避免全局变量污染，延长变量生命周期
闭包缺点
函数变量被保存在内存中，内存消耗大，不能滥用闭包，不然会造成网页的性能问题，
低版本IE中会内存泄漏.
解决方法在退出函数之前，将不使用的局部变量全部删除。

闭包的特点: 
1.函数嵌套函数
2.有返回值,且返回值一定是一个函数
v2中的data()与闭包有关



防抖

形象的的说就是:防止抖动(防抖函数内心独白:“你就抖动吧!等你不抖动了，我们在进行下一步”
例如
个搜索输入框， 用户不停的进行输入 (这个时候就是抖动的过程)等用户输入停止之后，再触发搜索。


节流
节流:节省交互沟通。
形象的的诞就是: no!no! no!一个一个来，按照时间节奏来!插队禁止!
例如
drag (拖动)事件或者 scroll (滚动) 期间触发某个毁掉，要设置一个时间间隔。这时候就不能使用防抖了，为什么呢?
防抖是拖搜或者滚动结束之后才返回回调，但是我是需要在过程中进行触发回调，但是又不需要那么的频繁;这时候就使用节流函数，每隔一定的时间进项触发就好了

事件循环，EventLoop
执行上下文
单线程: 从上到下执行
事件: 同步事件，异步事件，执行顺序是 先执行同步任务，在执行异步任务进栈
出栈
异步任务: 宏任务和微任务两种

同步任务:先进先出
异步任务: 取决于宏任务和微任务
微任务:先进先出

宏任务: setTimout,setInterval
微任务: .then .catch async await
同步任务: new Promise

什么是:EventLoop
任务分为同步任务和异步任务两种，先执行同步任务，在执行异步任务但是异步任务又分为两种，宏任务和微任务，先执行微任务，再执行宏任务



1.柯里化

柯里化(Currying)是 lambda 演算中的一个概念
柯里化是一个函数，它一次接受一个参数，并返回一个新函数，该函数期待下一个参数。它是一种函数转换，将f(a,b,c) 转换为可以被以f(a)(b)(c) 的形式进行调用。
JavaScript 中的柯里化是什么?
柯里化简单地说就是计算具有多个参数的函数，并将它们分解为具有单个参数的函数序列。
换句话说，柯里化是一个函数，而不是一次获取所有参数，获取第一个参数并返回一个新函数，该函数获取第二个参数并返回一个新函数，该函数获取第三个参数，以此类推，直到所有参数都完成。
实现柯里化
柯里化是一个接受多个参数的函数。它将把这个函数转换成一系列函数，每个小函数都接受一个参数


function a(a) {
        return (b) => {
            return (c) => {
                return a + b + c
            }
        }
    }
    console.log(a(1)(2)(3))

    function b(a, b, c) {
        return a + b + c
    }
    console.log(b(1, 2, 3))